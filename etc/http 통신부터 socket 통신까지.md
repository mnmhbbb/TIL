## 1. HTTP
아주 멋진(super보다 더 멋진 hyper) 텍스트를 전송하려고 만들어낸 통신 규약.  
서버가, html로 잘 만들어진 문서를 유저에게 잘 보여주는 것이 이 프로토콜의 최초 목적.  
+) HTTPS는 Secured 즉, 페이지를 request하고 response하는 것이 암호화됨  

- http의 대전제  
  클라이언트는 원하는 페이지를 url로 요청 -> 서버는 그 페이지를 보내줌(응답)  
  http클라이언트(웹브라우저)는 url을 보내고 결과를 받아오는 게 유일한 목적. 이고 유일하게 가능  
  **사용자가 url을 요청할 때만!** 서버에서 해당 페이지를 보내주는 식.  
  그래서 서버로부터 새 정보를 받아오려면 반드시 새 url을 요청해야만 한다.  

- 즉, 브라우저는 서버와 통신하려면 -> 다른 페이지로 이동해야 하는 대전제를 가진다.  
 >ex) 회원가입 아이디 중복체크 할 때,   
 >중복 검사를 요청하기 위해선 서버에게 새 페이지를 요청해야만 하는데,  
 >회원 정보 작성 중에 페이지를 이동할 수 없기 때문에  
 >새로 요청한 페이지를 팝업창으로 띄웠던 것.  
 >(요즘 사이트는 대부분 Ajax를 이용하여 팝업창없이 검사 가능)  
 >이러한 제한적인 환경 때문에 나타난 꼼수가 바로 ActiveX...  

## 2. AJAX
- 이때 구글에서 이 문제를 해결 -> `AJAX` 등장~~(사실 예전부터 있긴 했지만 거의 알려지지 않았음)~~  
  - 자바스크립트와 xml(html과 같은 마크업 언어 중 하나)을 이용한 비동기 통신.  
  - 서버와 통신하기 위해 `XHR` 객체를 사용하는 것.  
  - (자바스크립트에는 AJAX 요청을 생성하는 `XMLHttpRequest(XHR)`라는 API가 있음  
    웹 브라우저가 XHR를 이용해서 서버에 요청을 날리면 서버에 이에 대한 응답을 보내줌)  
&nbsp;  
- 동일한 웹페이지 내에서 DOM을 변경하여 결과를 반영함. 그래서 페이지 내부 변화만 일어남.  
  이를 통해 페이지 이동없이도 서버와 통신이 가능해졌다.  
- 검색창에 글자 한자씩 타이핑 될 때마다 웹서버에 단어를 보내 추천 검색어 리스트를 보여줄 수 있는 등    
  웹 브라우저만으로도 다양한 표현이 가능해졌다.    
- 비동기적으로 일부분만 업데이트 할 수 있는 AJAX로 인해, http 통신을 할 때 대전제였던 페이지 갱신이라는 제약은 무의미해졌다.   
&nbsp;    
1. 차이1 : 전체를 다 변경해야 하는가? vs 부분만 선별적으로 변경할 수 있는가?  
  - 나이브 HTTP는 클라이언트쪽에서 Request를 보내고 Server쪽에서 Response를 받으면 이어졌던 연결이 끊기게 되어있습니다. 그래서 화면의 내용을 갱신하기 위해서는 다시 request를 하고 response를 하면서 페이지 전체를 갱신하게 됩니다.  
  - AJAX는 html 페이지 전체가 아닌 **일부분만** 갱신할수 있도록 XMLHttpRequest객체를 통해 서버에 request 합니다. XMLHttpRequest는 서버와의 연결을 잡아둡니다. Json이나 xml형태로 필요한 데이터만 주고 받으며 DOM을 갱신하기 때문에 그만큼의 자원과 시간을 아낄 수 있습니다.  
&nbsp;  
2. 차이2 : 누가 서버에 유저의 니즈를 요청하는가?
  - 나이브한 HTTP는 웹브라우저가 서버에 요청합니다.   
  - AJAX는 XMLHttpRequest 객체가 서버에 요청합니다.   
&nbsp;  
이러한 기능을 통해 웹 메신저를 만드려고 했으나,  
ajax도 여전히 http로 서버와 통신하기 때문에 한계에 완전히 벗어나진 못했다.  
요청없이는 서버가 먼저 통신을 시작할 수 있는 방법이 없기 때문이다.  
서버는 응답밖에 할 수 없었다. 자유로운 양방향이 아닌 반쪽짜리 통신...  

2.5 comet  
클라이언트 요청이 없음에도 서버로부터 응답을 받는 상황을 해결  

## 3. SOCKET
이때 HTML5와 함께 등장한 것이 웹 소켓 프로토콜.   
- 브라우저와 서버가 **양방향 통신**을 할 수 있도록 지원하는 프로토콜.  
  웹 어플리케이션을 위한 양방향 통신 기법. 따라서 실시간 소통이 편리해짐.   
- HTTP에 의한 접속의 출발점이 클라이언트에 있다는 것에는 변험이 없지만, 한 번 접속을 확립하면 WebSocket을 사용하여 서버와 클라이언트 어느 쪽에서도 송신을 할 수 있게 됨.  
- 이와 같이 웹 소켓은 접속을 한 번 확립하면 유지하려고 하기 때문에, 접속을 자주하는 오버헤드가 적어지고 헤더의 사이즈도 작기 때문에 통신량을 줄일 수 있다. (헤더에 대한 내용은 추후 추가 예정)
- 클라이언트의 경우,  
  웹소켓을 지원하는 브라우저라면 자바스크립트에서 생성자를 호출해 소켓을 만들어 바로 사용하면 된다.  
- 서버의 경우라면 다수의 오픈 소스 모듈 중 선택해 구축할 수 있다.  
&nbsp;  
출처 :   
"HTTP에서부터 WEBSOCKET까지"<https://medium.com/@chullino/http%EC%97%90%EC%84%9C%EB%B6%80%ED%84%B0-websocket%EA%B9%8C%EC%A7%80-94df91988788>   
"Ajax 시작하기 - 웹 개발자 안내서 | MDN"<https://developer.mozilla.org/ko/docs/Web/Guide/AJAX/Getting_Started>  
"그림으로 배우는 Http & Network Basic"(우에노 센 지음. 이병억 옮김)
