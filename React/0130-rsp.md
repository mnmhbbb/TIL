#### 210130 리액트 공부
## 가위바위보 게임 실습
### 1. jsx에서 스타일 적용하기
- `{}`안에 객체형으로 입력하며 카멜케이스 방식을 사용한다.
```javascript
<div id="computer"
    style={{
            background: `url(https://en.pimg.jp/023/182/267/1/23182267.jpg) ${imgCoord} 0`,
          }}
        /><div>
```
- 또한, class를 사용할 경우 예약어이므로 `className` 키워드를 사용한다.   
&nbsp;
-------
### 2. 리액트 라이프사이클
- 컴포넌트가 생성되고 사라지는 과정에서 동작하는 작업들을 말함.
- 라이프사이클의 클래스와 훅스 방식이 일대일 대응으로 일치하지 않아서 사용할 때 헷갈릴 수 있다.
#### 2.1 클래스
- 모든 state에 대해 한 번에 작성하며, 상태에 따라 순차적으로 각 메서드가 실행된다.
#### 2.1.1 componentDidMount()
- 컴포넌트가 처음 렌더링 됐을 때 실행됨**(DOM 상에 삽입)**
- 여기에서 비동기 요청을 많이 한다.
#### 2.1.2 componentDidUpdate()
- 컴포넌트가 리렌더링 됐을 때 실행됨
- 컴포넌트 안에서 state나 props의 값이 변경될 때 리렌더가 일어나게 되는데,
- 이때 `shouldComponentUpdate`의 true가 되는 경우에 리렌더링이 되고
- 그런 후에 `componentDidUpdate`가 실행됨
#### 2.1.3 componentWillUnmount()
- 컴포넌트가 제거 되기 직전에 실행됨
- 부모 컴포넌트에 의해 자식 컴포넌트가 제거될 수 있는데 이때 실행되고 화면에서 사라짐**(DOM 상에서 제거)**
- 여기에서 비동기 요청 정리를 많이 함.
- 주로 `componentDidMount`에서 했던 작업들을 제거하는 용도.
- 만일 제거하는 경우가 아니면 이 과정은 실행하지 않음.
#### 2.1.4 적용 예시 - `setInterval`
- componentDidMount에 비동기 요청을 하고, componentWillUnmount에서 비동기 요청을 정리함. 이렇게 둘이 짝이 돼서 동작함.
- setInterval을 실행했는데 안없애주면 계속 돌아가서 메모리누수 문제가 발생함.
- 이렇게 완료되지 않은 비동기요청은 componentWillUnmount에서 처리해야 함.
```javascript
class RSP extends Component {
  //code...

  interval;

  componentDidMount() {
    this.interval = setInterval(this.changeHand, 100);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }
```
- 물론 이 예시에서는 setInterval을 제거하지 않기 때문에 체감이 잘 안 될 수도 있는데(클릭했을 때 멈추는 코드 있음)
만약에 자식 컴포넌트가 됐을 경우, 꼭 componentWillUnmount를 넣어야 메모리누수 문제가 생기지 않음.
#### 2.2 훅스
#### 2.2.1 useEffect
- 훅스에서는 `useEffect`를 사용하여 라이프사이클을 관리한다.
- state를 각각 담아도 되며, 한 번에 담아도 되는데, 상태가 변경되면 무조건 전체가 한 번에 실행됨.
- 훅스는 함수형 컴포넌트. 렌더될 때마다 해당 함수 컴포넌트 전체가 다시 실행되기 때문
--------
### 3. 고차함수
